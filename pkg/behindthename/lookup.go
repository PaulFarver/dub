package behindthename

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/pkg/errors"
)

type LookupParams struct {
	Exact bool
}

// Generated by https://quicktype.io

type ErrResponse struct {
	ErrorCode int    `json:"error_code,omitempty" yaml:"error_code,omitempty"`
	Error     string `json:"error,omitempty" yaml:"error,omitempty"`
}

type LookupResponse []LookupResponseElement

type LookupResponseElement struct {
	Name   string  `json:"name"`
	Gender string  `json:"gender"`
	Usages []Usage `json:"usages"`
}

type Usage struct {
	UsageCode   string `json:"usage_code"`
	UsageFull   string `json:"usage_full"`
	UsageGender string `json:"usage_gender"`
}

// Lookup will return information about a given name.
// https://www.behindthename.com/api/help.php
func (c *ClientImpl) Lookup(ctx context.Context, name string, params LookupParams) (*LookupResponse, error) {
	request := c.r.R()
	request.SetContext(ctx)
	request.SetQueryParams(map[string]string{
		"name":  name,
		"exact": strconv.FormatBool(params.Exact),
	})

	request.SetResult(&LookupResponse{})

	resp, err := request.Get("/lookup.json")
	if err != nil {
		errResp := &ErrResponse{}
		if err := json.Unmarshal(resp.Body(), errResp); err == nil && errResp.Error != "" {
			return nil, errors.Errorf("Error response from behindthename: code=%v error=%s", errResp.ErrorCode, errResp.Error)
		}
		return nil, err
	}


	response := resp.Result().(*LookupResponse)

	return response, nil
}
